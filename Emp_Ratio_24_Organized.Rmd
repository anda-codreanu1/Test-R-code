---
title: "Emp_Share_V0"
author: "Anda Codreanu"
date: "2025-09-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Code Summary

This code is used to calculate employment ratios per sector, and the output will be used in the IO model to calculate the indirect and direct job effects generated by gbiosolutions.

**Input files:**

-   Industry Output and Employment data from UNIDO - Employment_Share_data
-   OECD and IO industry codes
-   Output results from the IO Model Code: All_effects_affected, All_effects_affecting

**Output Files**:

-   IO_emp_output_ratio.xlsx = file with employment ratio values across industry x country pairs
-   All_effects_affected_Jobs = IO Outputs multiplied with job ratios to obtain the job effects
-   All_effects_affecting_Jobs

[**Missing Values Prioritization**]{.underline}:

For employment shares, there are cases when data is not available for every industry/country pair, either because employees count is not available or industry outputs. In that case, different inputation techniques are used, with the following prioritization order:

1.  **Use UNIDO data for job count or output**: the ideal case. Used when the activity exists on the UNIDO database, and when both the employee count and industry//country pair output is available
2.  **Using UNIDO data of jobs/output industry average**: the number will be inputed by calculating world average for the specific industry, if the industry is within the UNIDO database
3.  **Using the USA average from the WIOD:** (World Input-Output Database) from 2014 to calculate the jobs per output for the specific industry in the specific country

### Steps for running this code:

1.  Change the paths for import and export files to match your own folder structure
2.  Run the IO model code to be able to get the AFFECTED/AFFECTING output results
3.  Run the code below by clicking on the red arrow of each code box

## 1.1 Install Libraries

This part of the code has to be run only once, if you do not have the libraries installed

```{r instal-libraries}

install.packages(c("dplyr", "readxl", "writexl", "openxlsx", 
                   "tidyr", "tibble","purr" ))
```

## 1.2 Run Libraries

This part of the code has to be run only once, if you do not have the libraries installed

```{r run-libraries}

library(dplyr)
library(readxl)
library(writexl)
library(openxlsx)
library(purrr)
library(tidyr)
library(tibble)
```

## 2. Import Data

This part of code will import all the data needed across the script. ***Remember to change the folder structure*** to your own.

[Note: changer from swedish data to something else there - or check if by any change swedish data is used]{.underline}

```{r imports}

# Set Directory

setwd("C:/Users/AndaCodreanu/OneDrive - ADC/Desktop/Projects/Novonesis - The value of biosolutions/Code/Employment Model")

# Employment Share: contains data on Country/Industry Output and # of employees 
Emp_Share <- read_excel("Employment_Share_data.xlsx") %>%
  select(Year, Country, Keep, Output, Activity, ActivityCode , Employees)

# File containing the mapping of UNIDO activity codes to OECD codes:
UNIDO_OECD <- read_excel("Emp_Per_Output_Tentative.xlsx",sheet = "UNIDO_OECD_Key_clean")

# File containing the employee - output ratios (number of FTE / 1 EUR)
SE_Emp_Share <- read_xlsx("Swedish_Data.xlsx", sheet = "Sheet1")

#File containing Countries and industry codes, as well as a column of CodexCountry
IO_Cnt_Code <- read_excel("IO_Code.xlsx", sheet="Sheet1")

All_effects_affected <- read_excel("All_effects_affected.xlsx")

All_effects_affecting <- read_excel("All_effects_affecting.xlsx")
```

## 3. Data Processing

Merge and organize data. The dataset contains both output and employment data, so employment data is marked by k=1.

```{r pre-processing}

# Merge the Employment data with the activity code file. Keep only the OECD codes
Emp_Share <- left_join(Emp_Share, UNIDO_OECD, by = c("ActivityCode"), relationship = "many-to-many")

# Retain only observations where keep is 1 - Keep = 1 (Employment values)
Emp_Share_filtered <- Emp_Share %>%
  filter(Keep == 1)
```

## 4.1 Handling Missing Values - for industries with available data

This part begins with calculating employment shares using the first priority data, namely the ratios employment/output values across all Activity X Country X Year pairs. From all of these, only the most recent data is kept and the values are summarised to get the most recent Activity X Country pair value. Now the code uses the ratio if there is data, otherwise the world average.

When this data is not available, the code uses world industry averages. Specifically, it finds all the countries for which there is data on employment and output for Activity X across the world, then it averages them out to get a world average. This data is merged with the others to fill some of the missing values in, for those industries where there are countries with available data

Note: the first block makes use of available data to compute employment ratios when possible, while the second part expands the data to include all available combinations of industries and countries that may not be in the UNIDO data, hence the second one tries to build a more complete dataset

```{r missing values1}

#--------------------------------------------
# First Priority: Use Employment/Output Data
#--------------------------------------------

# Step 1: Calculate the employment share = Employees / Output for every industry/country/Year pair. Only applied if both values are available. 

employment_output <- Emp_Share_filtered %>%
  mutate(emp_output_ratio = ifelse(!is.na(Employees) & Employees != 0 & !is.na(Output) & Output != 0, 
                                   Employees / Output, 
                                   NA))

# Step 2: Find the newest year with employment/output data for each country and industry

newest_year_data <- employment_output %>%
  group_by(Country, ActivityCode) %>%
  filter(Year == max(Year)) %>%
  ungroup()

# Step 3: Select all rows with both employment and output data available and compute the values for each country x activity pair: 

collapsed_data <- newest_year_data %>%
  # Filter rows where both output and employees are positive
  filter(Output > 0, Employees > 0) %>%
  group_by(Country, IO_Code) %>%
  summarise(
    total_output = sum(Output),
    total_employees = sum(Employees),
    .groups = 'drop'  # This line prevents additional grouping messages
  ) %>%
  # Calculate the employee/output ratio
  mutate(employee_output_ratio = total_employees / total_output)

#----------------------------------------
# Second Priority: Use World Averages
#----------------------------------------

# Step 1: Calculate world averages
world_averages <- newest_year_data %>%
  # Filter rows where both output and employees are positive
  filter(Output > 0, Employees > 0) %>%
  # Group by IO_code to calculate world averages per IO_code
  group_by(IO_Code) %>%
  # Summarise to get the total sum of output and employees globally
  summarise(
    total_output = sum(Output),
    total_employees = sum(Employees)
  ) %>%
  # Calculate the weighted average employee/output ratio
  mutate(
    employee_output_ratio_world = total_employees / total_output
  )
world_averages <- world_averages %>%
  select(-total_output, -total_employees)

# Step 2: Perform a left join with 'final_data'
newest_year_data_v2 <- newest_year_data %>%
  left_join(collapsed_data, by = c("IO_Code", "Country"))

# Step 3: Attach to the World average and the country shares
newest_year_data_v3 <- newest_year_data_v2 %>%
  left_join(world_averages, by = c("IO_Code"))

# Step 4: Use normal average if there - otherwise world average
Unido_emp_ratio <- newest_year_data_v3 %>%
  mutate(
    emp_output = if_else(
      !is.na(employee_output_ratio), 
      employee_output_ratio, 
      employee_output_ratio_world
    )
  )

# Collapsing to no duplicates
Unido_emp_ratio_unique <- Unido_emp_ratio %>%
  group_by(Country, IO_Code) %>%
  summarise(
    employment_output = mean(emp_output, na.rm = TRUE),
  )
```

## 4.2 Handling Missing Values - for the rest of the industries

This part of the code further aims to fill in the missing values, especially for the industries and countries fo rwhich UNIDO data is not available from the first dataset. First it generates a complete dataset which contains a row for every country, industry combination, and data is added from the unido_emp_ratio_unique, to fill in the data with what is already known. This is further joined with the Swedish Data containing employment ratios for each industry, and an if statement ensures that if the employment output data is available from the unido dataset, it uses that, othetrwise it uses data from Sweden. Further, the code imports a new list of countries and activities codes from OECD which is merged with the current dataframe, and on top of it it is re-attached the world_averages, and the swedish employment ratios. At this point with all the merges there is a complete list of inustryxcountry codes. if data comes from UNIDO for both employment and output, it is kept. Otherwise, the next is industry world average, and after that data from the SE dataset.

```{r analysis2}

# Getting the rest of the industries
# Step 1: Create a complete dataset of all combinations of countries and industry codes
countries <- unique(Unido_emp_ratio_unique$Country)
industry_codes <- unique(SE_Emp_Share$IO_Code)
complete_data <- expand_grid(Country = countries, IO_Code = industry_codes)

complete_data_2 <- complete_data %>%
  left_join(Unido_emp_ratio_unique, by = c("Country", "IO_Code"))

# Left join SE data
complete_data_3 <- complete_data_2 %>%
  left_join(SE_Emp_Share, by = c("IO_Code"))

# Create a new column 'new_column' based on the condition, then make sure to only keep the relevant columns
complete_data_4 <- complete_data_3 %>%
  mutate(emp_output = ifelse(!is.na(employment_output), employment_output, employment_output_se)) %>%
  select(Country, IO_Code, emp_output)

# Change format
IO_Cnt_Code_v2 <- IO_Cnt_Code %>%
  left_join(complete_data_4, by = c("Country", "IO_Code"))

# Attach to the World average and the country shares
IO_Cnt_Code_v2 <- IO_Cnt_Code_v2 %>%
  left_join(world_averages, by = c("IO_Code"))

IO_Cnt_Code_v2 <- IO_Cnt_Code_v2 %>%
  left_join(SE_Emp_Share, by = c("IO_Code"))

# Step many: Use normal average if there - otherwise world average
IO_emp_output_ratio <- IO_Cnt_Code_v2 %>%
  mutate(
    emp_output = if_else(
      !is.na(emp_output), 
      emp_output, 
      coalesce(employee_output_ratio_world, employment_output_se)
    )
  )
```

## 5. Merge with IO Model data

The code first imports the affected effects calculated in the IO Model. It is to be noted that while the IO Model code imports the employment ratios, they are only used within a small sectio n of the code, and the general IO results are computed independently of the employment ratios.\
The first step i sto import the IO matrix and organize it to fit with the employmet dataframes, then merge with the IO_emp_output_ratio dataframe. The next step is to multiply all output values with the employment ratios to obtain the number of jobs.

```{r analysis3}

#----------------------------
# Merge with AFFECTED data
#----------------------------
# Organize the AFFECTED data 
All_effects_affected <- t(All_effects_affected) %>%
  as.data.frame() %>%
  rownames_to_column(var = "IO_Cnt_Code") %>%
  rename(
    Total_output = V1,
    Direct_output = V2,
    Indirect_output = V3
  )

#merge with the employment ratio dataframe
All_effects_affected_Jobs <- All_effects_affected %>%
  left_join(IO_emp_output_ratio, by = c("IO_Cnt_Code"))

# Multiply all columns with employment ratios
All_effects_affected_Jobs <- All_effects_affected_Jobs %>%
  mutate(
    Total_employment = emp_output * Total_output,
    Direct_employment = emp_output * Direct_output,
    Indirect_employment = emp_output * Indirect_output,
  )
#calculate affected jobs by country 
All_effects_affected_cnt <- All_effects_affected_Jobs %>%
  group_by(Country) %>%
  summarise(across(where(is.numeric), sum, na.rm = TRUE))

All_effects_affected_cnt <- All_effects_affected_cnt %>%
  select(-emp_output, -employment_output_se, -employee_output_ratio_world)

#----------------------------
# Merge with AFFECTING data
#----------------------------

# Organize the AFFECING output dataset 
All_effects_affecting <-t(All_effects_affecting)
All_effects_affecting <-as.data.frame(All_effects_affecting)
All_effects_affecting <- All_effects_affecting %>%
  rownames_to_column(var = "IO_Cnt_Code")

All_effects_affecting <- All_effects_affecting %>%
  rename(Total_output = V1)
All_effects_affecting <- All_effects_affecting %>%
  rename(Direct_output = V2)
All_effects_affecting <- All_effects_affecting %>%
  rename(Indirect_output = V3)

All_effects_affecting_Jobs <- All_effects_affecting %>%
  left_join(IO_emp_output_ratio, by = c("IO_Cnt_Code"))

# Multiply output values with emp multipliers
All_effects_affecting_Jobs <- All_effects_affecting_Jobs %>%
  mutate(
    Total_employment = emp_output * Total_output,
    Direct_employment = emp_output * Direct_output,
    Indirect_employment = emp_output * Indirect_output,
  )

# Affecting results grouped by country 
All_effects_affecting_cnt <- All_effects_affecting_Jobs %>%
  group_by(Country) %>%
  summarise(across(where(is.numeric), sum, na.rm = TRUE))

All_effects_affecting_cnt <- All_effects_affecting_cnt %>%
  select(-emp_output, -employment_output_se, -employee_output_ratio_world)
```

## Exports

```{r exports}
# Step 4 Export results
write_xlsx(IO_emp_output_ratio, "IO_emp_output_ratio.xlsx")

# Export jobs affected
write_xlsx(All_effects_affected_Jobs, "All_effects_affected_Jobs.xlsx")

# Jobs affected by country 
write_xlsx(All_effects_affected_cnt, "All_effects_affected_cnt.xlsx")

# Export results affectING
write_xlsx(All_effects_affecting_Jobs, "All_effects_affecting_Jobs.xlsx")

#Affecting reults by country 
write_xlsx(All_effects_affecting_cnt, "All_effects_affecting_cnt.xlsx")

```
