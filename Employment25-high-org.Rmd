---
title: "Emp_Share_V0"
author: "Anda Codreanu"
date: "2025-09-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Code Summary

This code is used to calculate employment ratios per sector, and the output will be used in the IO model to calculate the indirect and direct job effects generated by biosolutions. Note: This is the code used for the 2025 Forecast with normal rate. The only difference between this and the other employment code is that it imports the output files of the IO model ***from the Forecast 2025 High rate folder, rather than the 2024 data. Hence, ensure you reference the correct folder. Paths need to be changed for both the input and output.***

**Input files:**

-   Industry Output and Employment data from UNIDO - Employment_Share_data
-   OECD and IO industry codes
-   Output results from the IO Model Code: All_effects_affected, All_effects_affecting

**Output Files**:

-   IO_emp_output_ratio.xlsx = file with employment ratio values across industry x country pairs
-   All_effects_affected_Jobs = IO Outputs multiplied with job ratios to obtain the job effects
-   All_effects_affecting_Jobs

[**Missing Values Prioritization**]{.underline}:

For employment shares, data is not always available for every industry–country pair. This may occur because employee counts or industry outputs are missing, or because the industry does not exist in both the OECD and UNIDO classifications. In such cases, imputation techniques are applied following this prioritization order:

1.  **Use UNIDO data for job count or output**: the ideal case. Used when the activity exists on the UNIDO database, and when both the employee count and industry//country pair output is available
2.  **Using UNIDO data of jobs/output industry average**: the number will be inputed by calculating world average for the specific industry, if the industry is within the UNIDO database
3.  **Using the USA average from the WIOD:** (World Input-Output Database) from 2014 to calculate the jobs per output for the specific industry in the specific country

### Steps for running this code:

1.  Change the paths for import and export files to match your own folder structure
2.  Run the IO model code to be able to get the AFFECTED/AFFECTING output results
3.  Run the code below by clicking on the red arrow of each code box

## 1.1 Install Libraries

This part of the code has to be run only once, if you do not have the libraries installed

```{r instal-libraries}

install.packages(c("dplyr", "readxl", "writexl", "openxlsx", 
                   "tidyr", "tibble","purr" ))
```

## 1.2 Run Libraries

This part of the code has to be run only once, if you do not have the libraries installed

```{r run-libraries}

library(dplyr)
library(readxl)
library(writexl)
library(openxlsx)
library(purrr)
library(tidyr)
library(tibble)
```

## 2. Import Data

This part of code will import all the data needed across the script. ***Remember to change the folder structure*** to your own.

[Note: changer from swedish data to something else there - or check if by any change swedish data is used]{.underline}

```{r imports}

# Set Directory

setwd("C:/Users/AndaCodreanu/OneDrive - ADC/Desktop/Projects/Novonesis - The value of biosolutions/Code/Employment Model")

# Employment Share: contains data on Country/Industry Output and # of employees 
Emp_Share <- read_excel("Employment_Share_data.xlsx") %>%
  select(Year, Country, Keep, Output, Activity, ActivityCode , Employees)

# File containing the mapping of UNIDO activity codes to OECD codes:
UNIDO_OECD <- read_excel("Emp_Per_Output_Tentative.xlsx",sheet = "UNIDO_OECD_Key_clean")

# File containing the employee - output ratios (number of FTE / 1 EUR)
SE_Emp_Share <- read_xlsx("Swedish_Data.xlsx", sheet = "Sheet1")

#File containing Countries and industry codes, as well as a column of CodexCountry
IO_Cnt_Code <- read_excel("IO_Code.xlsx", sheet="Sheet1")

#Import Affected and Affecting outputs from the IO model-make sure to follow the folder structure

# Import the affected and export
All_effects_affected <- read_excel("C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/Forecast/All_effects_affected_high25.xlsx")

All_effects_affecting <- read_excel("C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/Forecast/All_effects_affecting_high25.xlsx")


```

## 3. Data Processing

Merge and organize data. The dataset contains both output and employment data, so employment data is marked by k=1.

```{r pre-processing}

# Merge the Employment data with the activity code file. Keep only the OECD codes
Emp_Share <- left_join(Emp_Share, UNIDO_OECD, by = c("ActivityCode"), relationship = "many-to-many")

# Retain only observations where keep is 1 - Keep = 1 (Employment values)
Emp_Share_filtered <- Emp_Share %>%
  filter(Keep == 1)
```

## 4.1 Handling Missing Values - for industries with available data

This section starts by calculating employment shares using the highest-priority data: the employment-to-output ratios across all Activity × Country × Year combinations. From these, only the most recent year is retained, and values are aggregated to obtain the latest estimate for each Activity × Country pair. If a country-specific ratio is available, it is used; otherwise, the world average is applied.

When country-level data is missing, the code relies on global industry averages. It does this by identifying all countries with available employment and output data for a given activity, calculating a weighted world average, and merging these values to fill remaining gaps for industries with partial coverage.

**Note:** The first block focuses on leveraging available data to compute employment ratios wherever possible, while the second block expands the dataset to include all required industry–country combinations, even those absent from the UNIDO data, thereby creating a more complete and consistent dataset.

```{r missing values1}

#--------------------------------------------
# First Priority: Use Employment/Output Data
#--------------------------------------------

# Step 1: Calculate the employment share = Employees / Output for every industry/country/Year pair. Only applied if both values are available. 

employment_output <- Emp_Share_filtered %>%
  mutate(emp_output_ratio = ifelse(!is.na(Employees) & Employees != 0 & !is.na(Output) & Output != 0, 
                                   Employees / Output, 
                                   NA))

# Step 2: Find the newest year with employment/output data for each country and industry

newest_year_data <- employment_output %>%
  group_by(Country, ActivityCode) %>%
  filter(Year == max(Year)) %>%
  ungroup()

# Step 3: Select all rows with both employment and output data available and compute the values for each country x activity pair: 

collapsed_data <- newest_year_data %>%
  # Filter rows where both output and employees are positive
  filter(Output > 0, Employees > 0) %>%
  group_by(Country, IO_Code) %>%
  summarise(
    total_output = sum(Output),
    total_employees = sum(Employees),
    .groups = 'drop'  # This line prevents additional grouping messages
  ) %>%
  # Calculate the employee/output ratio
  mutate(employee_output_ratio = total_employees / total_output)

#----------------------------------------
# Second Priority: Use World Averages
#----------------------------------------

# Step 1: Calculate world averages
world_averages <- newest_year_data %>%
  # Filter rows where both output and employees are positive
  filter(Output > 0, Employees > 0) %>%
  # Group by IO_code to calculate world averages per IO_code
  group_by(IO_Code) %>%
  # Summarise to get the total sum of output and employees globally
  summarise(
    total_output = sum(Output),
    total_employees = sum(Employees)
  ) %>%
  # Calculate the weighted average employee/output ratio
  mutate(
    employee_output_ratio_world = total_employees / total_output
  )
world_averages <- world_averages %>%
  select(-total_output, -total_employees)

# Step 2: Perform a left join with 'final_data'
newest_year_data_v2 <- newest_year_data %>%
  left_join(collapsed_data, by = c("IO_Code", "Country"))

# Step 3: Attach to the World average and the country shares
newest_year_data_v3 <- newest_year_data_v2 %>%
  left_join(world_averages, by = c("IO_Code"))

# Step 4: Use normal average if there - otherwise world average
Unido_emp_ratio <- newest_year_data_v3 %>%
  mutate(
    emp_output = if_else(
      !is.na(employee_output_ratio), 
      employee_output_ratio, 
      employee_output_ratio_world
    )
  )

# Collapsing to no duplicates
Unido_emp_ratio_unique <- Unido_emp_ratio %>%
  group_by(Country, IO_Code) %>%
  summarise(
    employment_output = mean(emp_output, na.rm = TRUE),
  )
```

## 4.2 Handling Missing Values - for the rest of the industries

This part of the code further aims to fill in the missing values, especially for the industries and countries for which UNIDO data is not available from the first dataset. First it generates a complete dataset which contains a row for every country, industry combination, and data is added from the unido_emp_ratio_unique, to fill in the data with what is already known. This is further joined with the Swedish Data containing employment ratios for each industry, and an if statement ensures that if the employment output data is available from the unido dataset, it uses that, otherwise it uses data from Sweden. Further, the code imports a new list of countries and activities codes from OECD which is merged with the current dataframe, and on top of it it is re-attached the world_averages, and the swedish employment ratios. At this point with all the merges there is a complete list of inustryxcountry codes. if data comes from UNIDO for both employment and output, it is kept. Otherwise, the next is industry world average, and after that data from the SE dataset.

```{r analysis2}

# Getting the rest of the industries
# Step 1: Create a complete dataset of all combinations of countries and industry codes
countries <- unique(Unido_emp_ratio_unique$Country)
industry_codes <- unique(SE_Emp_Share$IO_Code)
complete_data <- expand_grid(Country = countries, IO_Code = industry_codes)

complete_data_2 <- complete_data %>%
  left_join(Unido_emp_ratio_unique, by = c("Country", "IO_Code"))

# Left join SE data
complete_data_3 <- complete_data_2 %>%
  left_join(SE_Emp_Share, by = c("IO_Code"))

# Create a new column 'new_column' based on the condition, then make sure to only keep the relevant columns
complete_data_4 <- complete_data_3 %>%
  mutate(emp_output = ifelse(!is.na(employment_output), employment_output, employment_output_se)) %>%
  select(Country, IO_Code, emp_output)

# Change format
IO_Cnt_Code_v2 <- IO_Cnt_Code %>%
  left_join(complete_data_4, by = c("Country", "IO_Code"))

# Attach to the World average and the country shares
IO_Cnt_Code_v2 <- IO_Cnt_Code_v2 %>%
  left_join(world_averages, by = c("IO_Code"))

IO_Cnt_Code_v2 <- IO_Cnt_Code_v2 %>%
  left_join(SE_Emp_Share, by = c("IO_Code"))

# Step many: Use normal average if there - otherwise world average
IO_emp_output_ratio <- IO_Cnt_Code_v2 %>%
  mutate(
    emp_output = if_else(
      !is.na(emp_output), 
      emp_output, 
      coalesce(employee_output_ratio_world, employment_output_se)
    )
  )
```

## 5. Merge with IO Model data

The code first imports the affected effects calculated in the IO Model. It is to be noted that while the IO Model code imports the employment ratios, they are only used within a small section of the code, and the general IO results are computed independently of the employment ratios.\
The first step is to import the IO matrix and organize it to fit with the employment dataframes, then merge with the IO_emp_output_ratio dataframe. The next step is to multiply all output values with the employment ratios to obtain the number of jobs.

```{r analysis3}

#----------------------------
# Merge with AFFECTED data
#----------------------------
# Organize the AFFECTED data 
All_effects_affected <- t(All_effects_affected) %>%
  as.data.frame() %>%
  rownames_to_column(var = "IO_Cnt_Code") %>%
  rename(
    Total_output = V1,
    Direct_output = V2,
    Indirect_output = V3
  )

#merge with the employment ratio dataframe
All_effects_affected_Jobs <- All_effects_affected %>%
  left_join(IO_emp_output_ratio, by = c("IO_Cnt_Code"))

# Multiply all columns with employment ratios
All_effects_affected_Jobs <- All_effects_affected_Jobs %>%
  mutate(
    Total_employment = emp_output * Total_output,
    Direct_employment = emp_output * Direct_output,
    Indirect_employment = emp_output * Indirect_output,
  )
#calculate affected jobs by country 
All_effects_affected_cnt <- All_effects_affected_Jobs %>%
  group_by(Country) %>%
  summarise(across(where(is.numeric), sum, na.rm = TRUE))

All_effects_affected_cnt <- All_effects_affected_cnt %>%
  select(-emp_output, -employment_output_se, -employee_output_ratio_world)

#----------------------------
# Merge with AFFECTING data
#----------------------------

# Organize the AFFECING output dataset 
All_effects_affecting <-t(All_effects_affecting)
All_effects_affecting <-as.data.frame(All_effects_affecting)
All_effects_affecting <- All_effects_affecting %>%
  rownames_to_column(var = "IO_Cnt_Code")

All_effects_affecting <- All_effects_affecting %>%
  rename(Total_output = V1)
All_effects_affecting <- All_effects_affecting %>%
  rename(Direct_output = V2)
All_effects_affecting <- All_effects_affecting %>%
  rename(Indirect_output = V3)

All_effects_affecting_Jobs <- All_effects_affecting %>%
  left_join(IO_emp_output_ratio, by = c("IO_Cnt_Code"))

# Multiply output values with emp multipliers
All_effects_affecting_Jobs <- All_effects_affecting_Jobs %>%
  mutate(
    Total_employment = emp_output * Total_output,
    Direct_employment = emp_output * Direct_output,
    Indirect_employment = emp_output * Indirect_output,
  )

# Affecting results grouped by country 
All_effects_affecting_cnt <- All_effects_affecting_Jobs %>%
  group_by(Country) %>%
  summarise(across(where(is.numeric), sum, na.rm = TRUE))

All_effects_affecting_cnt <- All_effects_affecting_cnt %>%
  select(-emp_output, -employment_output_se, -employee_output_ratio_world)
```

## Exports

Make sure to have the correct folder structure here, and all the exports to be done to the correct export folder, for the other codes to work.

```{r exports}
# Step 4 Export results
write_xlsx(IO_emp_output_ratio, "IO_emp_output_ratio.xlsx")

# Export jobs affected
write_xlsx(All_effects_affected_Jobs, "C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/All_effects_affected_Jobs_high25.xlsx")

# Jobs affected by country 
write_xlsx(All_effects_affected_cnt, "C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/All_effects_affected_cnt_high25.xlsx")

# Export results affectING
write_xlsx(All_effects_affecting_Jobs, "C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/All_effects_affecting_Jobs_high25.xlsx")

#Affecting reults by country 
write_xlsx(All_effects_affecting_cnt, "C:/Users/MarcSkovJacobsenADC/ADC/ADC Denmark MNO - Client Folders N/Novonesis/2024/Global socio-economic value of biosolutions/3. Project Execution/IO/Results/All_effects_affecting_cnt_high25.xlsx")
```
